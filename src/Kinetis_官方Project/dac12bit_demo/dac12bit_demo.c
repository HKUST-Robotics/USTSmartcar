 /*
 * File:		dac12bit_demo.c
 * Purpose:		Main process
 * TWR-K40X256, REVA. User can probe DAC0(L3) at test point TP18 and DAC1(L4) at test point TP16
 * TWR-K60N512, REVA. User can probe DAC0(L3) at test point TP23 and DAC1(L4) at test point TP22 
 * TWR-K40X256, REVB. User can probe DAC0(L3) at test point TP4  and DAC1(L4) at test point TP3
 * TWR-K60N512, REVC. User can probe DAC0(L3) at test point TP1  and DAC1(L4) at test point TP7
 * TWR-K53N512, REVC. User can probe DAC0(K4) at test point TP1  and DAC1(J4) at test point TP3
* Rev 1 15 OCT 2010
*
*/

#include "common.h"
#include "dac12bit.h"
/********************************************************************/
void main (void)
{
	char ch ='0';
        dac0_1_clk_enable();  //enabled system clock to DAC module.
        
  	printf("\nWelcome to the Kinetis 12-bit DAC module DEMOs. \n");      
        printf("\nPlease select the following option for the specfific demo\n\n"); 
    
       printf("\nYou will need to restart the application everytime you finish each demo\n"); 	
       ch = in_char();
        
	while(1)
	{
         
                      
                switch(ch){
                
                case '1':  
                /*  
                DEMO 1:
                This demo showcases DAC module's capability to select an input reference voltage from either  
                1 ) The external VDDA pin 
                2 ) The internal on-chip fixed reference voltage from the output of the VREF module.
                You will observe at each of the DAC0 and DAC1 pin, a repeated ramp linear signal will be generated. 
                The peak/max of the ramp signal generated by DAC0 or DAC1 is restricted by the corresponding input voltage reference value. 
                Since DAC0 selects at a lower input voltage reference from VREF output at about 1.2V(varies from part to part) and DAC1 selects a higher input voltage
                reference from VDDA pin at about 3.3V, the peak of DAC0 signal will be less than the DAC1 signal
                Notice Demo 1 sets up DAC modules in non-buffer mode. This means that DAC output solely base on the 
                  digital value stores at DAC_DAT0 register. As in buffered mode, the DAC output value is base on the DAC_DATx value where the read pointer
                points to.
                */
                
                DACx_reset_dac0_1_reg_values();//reinitialize DAC0 and DAC1 registers to default reset values;
                DAC12_VreferenceInit(DAC0_BASE_PTR, DAC_SEL_VREFO);//DAC0 initialized as: Non-buffer mode and select VREF Output as reference  
                DAC12_VreferenceInit(DAC1_BASE_PTR, DAC_SEL_VDDA);//DAC1 initialized as: Non-buffer mode and select VDDA as reference 
                DAC12_VreferenceRamp(); //Ramp dac output from 0 to 4095 <=> DAC output = input reference voltage/4096 to input reference voltage(See datasheet for output restriction)
                
                ch ='0';
               
                break;
                 
                case '2':
                /*DEMO 2: 
                This demo showcases the DAC module capability when configured as buffered mode
                When DAC is enabled buffered mode, the DAC output value is base on the DAC_DATx 
                value where the read pointer points to. There are totally 16 word DAC buffer(DAC_DAT0 to DAC_DAT16) for each
                DAC module. There are two configuration that you can choose to advance the read pointer to the next
                buffer. One is Software trigger another is hardware trigger by PDB timmer module. Also, in buffer mode
                You can define where the read pointer goes to after reading the top limit pointer.
                we will show case Software trigger and Normal mode.
               */
                 DACx_reset_dac0_1_reg_values();//reset DAC0 and DAC1 value to default reset value;  
                 
                 DAC12_SoftTrigBuffInit(DAC0_BASE_PTR, DAC_BF_NORMAL_MODE, DAC_SEL_VREFO,DAC_SEL_SW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15) ) ; 
                 DAC12_SoftTrigBuffInit(DAC1_BASE_PTR, DAC_BF_NORMAL_MODE, DAC_SEL_VDDA,DAC_SEL_SW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15) ) ; 
                 DAC12_SoftwareTriggerLoop();
                
                 ch ='0';
                 break;
                 
                case '3':
                 /*DEMO 3
                 Same configuration from DEMO 2 except we are runing in SWING mode.
                 Observe DACx output, you will notice the ramp will go down after it ramp up.
                 */
                 
                 DACx_reset_dac0_1_reg_values();//reset DAC0 and DAC1 value to default reset value;  
                 DAC12_SoftTrigBuffInit(DAC0_BASE_PTR, DAC_BF_SWING_MODE, DAC_SEL_VREFO,DAC_SEL_SW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15) ) ; 
                 DAC12_SoftTrigBuffInit(DAC1_BASE_PTR, DAC_BF_SWING_MODE, DAC_SEL_VDDA,DAC_SEL_SW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15) ) ; 
                 DAC12_SoftwareTriggerLoop();
                 
                 ch ='0';
                break;
                
                case '4':
                   /*DEMO 4
                 Same configuration from DEMO 3 except we are runing in ONE_TIME mode. 
                 Observe DACx output, you will notice the ramp up will only occur once and won't repeat.
                 */
                  DACx_reset_dac0_1_reg_values();//reset DAC0 and DAC1 value to default reset value;  
                 DAC12_SoftTrigBuffInit(DAC0_BASE_PTR, DAC_BF_ONE_TIME_MODE, DAC_SEL_VREFO,DAC_SEL_SW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15) ) ; 
                 DAC12_SoftTrigBuffInit(DAC1_BASE_PTR, DAC_BF_ONE_TIME_MODE, DAC_SEL_VDDA,DAC_SEL_SW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15) ) ; 
                 DAC12_SoftwareTriggerLoop(); 
                 
                 ch ='0';
                break;
                
                
                case '5':
                /*DEMO 5
                 This is an example of using hardware trigger by the PDB module, to advance to the next 
                  read pointer in buffer mode. You will notice DAC output changes intervals are defined by the 
                  value specified in the PDB_DACINTx register. See PDB_DAC0_TriggerInit or PDB_DAC1_TriggerInit
                  for detail.
                 */
 
             
                  DACx_reset_dac0_1_reg_values();//reset DAC0 and DAC1 value to default reset value;  
                  DAC12_HWTrigBuff(DAC0_BASE_PTR, DAC_BF_SWING_MODE,DAC_SEL_VREFO,DAC_SEL_PDB_HW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15)) ;  
                  DAC12_HWTrigBuff(DAC1_BASE_PTR, DAC_BF_SWING_MODE,DAC_SEL_VDDA,DAC_SEL_PDB_HW_TRIG,DAC_SET_PTR_AT_BF(0),DAC_SET_PTR_UP_LIMIT(15)) ;  
                   
                  ch ='0';
                  
                  break;
                
           
                 
                 default:
     
                  break;
                
                
                
                }  //end of switch statement    
                
	} 
        
        
}
/********************************************************************/
